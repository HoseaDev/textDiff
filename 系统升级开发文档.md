# TextDiff 系统升级开发文档

## 一、现状分析与需求评估

### 1.1 当前系统能力
- ✅ 单文档版本管理
- ✅ 版本对比和差异显示
- ✅ 自动保存/手动保存
- ✅ 版本恢复功能
- ✅ WebSocket 实时协作基础

### 1.2 存在的问题
1. **单文档限制**：只能管理单篇文章，无法处理多文档场景
2. **无用户系统**：缺少用户认证和权限管理
3. **数据库限制**：使用 SQLite，不适合生产环境
4. **时区问题**：时间显示错误（UTC vs 本地时间，8小时偏差）
5. **缺少文档组织**：没有文件夹/项目/分类管理
6. **无权限控制**：所有人都能访问所有文档

### 1.3 升级需求
- 🔴 **多文档管理系统**
- 🔴 **用户认证与授权**
- 🔴 **MySQL 数据库支持**
- 🔴 **修复时区问题**
- 🟡 文档分类与组织
- 🟡 协作与权限管理
- 🟡 搜索功能

---

## 二、系统架构升级方案

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────┐
│                   前端 (Vue 3 + TypeScript)              │
│  ┌─────────────────────────────────────────────────┐   │
│  │  路由守卫 → 登录页 → 文档列表 → 文档编辑器      │   │
│  │  用户管理 | 权限控制 | 多文档切换 | 搜索       │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                            ↓↑
                     [JWT Token 认证]
                            ↓↑
┌─────────────────────────────────────────────────────────┐
│                后端 (FastAPI + SQLAlchemy)              │
│  ┌─────────────────────────────────────────────────┐   │
│  │  认证中间件 → 用户服务 → 文档服务 → 版本服务    │   │
│  │  权限检查 | 多租户 | 文档索引 | 全文搜索       │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                            ↓↑
┌─────────────────────────────────────────────────────────┐
│                    MySQL 8.0+ 数据库                     │
│  ┌─────────────────────────────────────────────────┐   │
│  │  users | documents | versions | permissions     │   │
│  │  folders | shares | audit_logs | sessions       │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 2.2 数据库设计（MySQL）

#### 2.2.1 用户相关表

```sql
-- 用户表
CREATE TABLE users (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(100),
    avatar_url VARCHAR(500),
    is_active BOOLEAN DEFAULT TRUE,
    is_superuser BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP NULL,
    timezone VARCHAR(50) DEFAULT 'Asia/Shanghai',
    INDEX idx_email (email),
    INDEX idx_username (username)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 用户会话表
CREATE TABLE user_sessions (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    token VARCHAR(500) NOT NULL,
    refresh_token VARCHAR(500),
    expires_at TIMESTAMP NOT NULL,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_token (token),
    INDEX idx_user_expires (user_id, expires_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 2.2.2 文档组织表

```sql
-- 文件夹/项目表
CREATE TABLE folders (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    parent_id VARCHAR(36),
    owner_id VARCHAR(36) NOT NULL,
    color VARCHAR(7),  -- HEX 颜色
    icon VARCHAR(50),   -- 图标名
    is_public BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_id) REFERENCES folders(id) ON DELETE CASCADE,
    FOREIGN KEY (owner_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_owner (owner_id),
    INDEX idx_parent (parent_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 更新文档表
ALTER TABLE documents ADD COLUMN folder_id VARCHAR(36);
ALTER TABLE documents ADD COLUMN owner_id VARCHAR(36) NOT NULL;
ALTER TABLE documents ADD COLUMN is_public BOOLEAN DEFAULT FALSE;
ALTER TABLE documents ADD COLUMN view_count INT DEFAULT 0;
ALTER TABLE documents ADD COLUMN star_count INT DEFAULT 0;
ALTER TABLE documents ADD COLUMN last_accessed_at TIMESTAMP NULL;
ALTER TABLE documents ADD FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE SET NULL;
ALTER TABLE documents ADD FOREIGN KEY (owner_id) REFERENCES users(id) ON DELETE CASCADE;
ALTER TABLE documents ADD INDEX idx_owner_folder (owner_id, folder_id);
ALTER TABLE documents ADD FULLTEXT INDEX ft_title_search (title);
```

#### 2.2.3 权限与协作表

```sql
-- 文档权限表
CREATE TABLE document_permissions (
    id VARCHAR(36) PRIMARY KEY,
    document_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    permission ENUM('view', 'edit', 'admin') NOT NULL,
    granted_by VARCHAR(36) NOT NULL,
    granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NULL,
    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (granted_by) REFERENCES users(id),
    UNIQUE KEY unique_doc_user (document_id, user_id),
    INDEX idx_user_docs (user_id, permission)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 文档分享链接表
CREATE TABLE document_shares (
    id VARCHAR(36) PRIMARY KEY,
    document_id VARCHAR(36) NOT NULL,
    share_code VARCHAR(20) UNIQUE NOT NULL,
    created_by VARCHAR(36) NOT NULL,
    permission ENUM('view', 'edit') DEFAULT 'view',
    password VARCHAR(255),  -- 可选密码保护
    expires_at TIMESTAMP NULL,
    max_views INT,  -- 最大访问次数
    view_count INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE,
    FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_share_code (share_code)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 收藏表
CREATE TABLE user_favorites (
    user_id VARCHAR(36) NOT NULL,
    document_id VARCHAR(36) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, document_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 2.2.4 审计日志表

```sql
-- 操作日志表
CREATE TABLE audit_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(36),
    document_id VARCHAR(36),
    action VARCHAR(50) NOT NULL,  -- create, update, delete, view, share
    details JSON,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_action (user_id, action),
    INDEX idx_document (document_id),
    INDEX idx_created (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 2.2.5 修复版本表时区

```sql
-- 更新版本表，添加用户关联
ALTER TABLE versions ADD COLUMN author_id VARCHAR(36);
ALTER TABLE versions ADD FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE SET NULL;

-- 修复时间字段，使用 MySQL 的时区支持
ALTER TABLE versions MODIFY created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;
ALTER TABLE documents MODIFY created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;
ALTER TABLE documents MODIFY updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;
```

---

## 三、后端实现方案

### 3.1 用户认证系统

#### 3.1.1 JWT 认证实现

```python
# backend/app/core/auth.py
from datetime import datetime, timedelta
from typing import Optional
import jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()

class AuthService:
    @staticmethod
    def hash_password(password: str) -> str:
        return pwd_context.hash(password)

    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return pwd_context.verify(plain_password, hashed_password)

    @staticmethod
    def create_access_token(user_id: str, expires_delta: timedelta = timedelta(hours=24)):
        expire = datetime.utcnow() + expires_delta
        payload = {
            "sub": user_id,
            "exp": expire,
            "iat": datetime.utcnow()
        }
        return jwt.encode(payload, settings.SECRET_KEY, algorithm="HS256")

    @staticmethod
    def decode_token(token: str) -> dict:
        try:
            payload = jwt.decode(token, settings.SECRET_KEY, algorithms=["HS256"])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="Token expired")
        except jwt.JWTError:
            raise HTTPException(status_code=401, detail="Invalid token")

# 依赖注入：获取当前用户
async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    token = credentials.credentials
    payload = AuthService.decode_token(token)
    user_id = payload.get("sub")

    # 从数据库获取用户
    user = UserService.get_user(db, user_id)
    if not user:
        raise HTTPException(status_code=401, detail="User not found")

    return user
```

#### 3.1.2 用户服务

```python
# backend/app/services/user_service.py
from typing import Optional, List
from sqlalchemy.orm import Session
from ..models.user import User
from ..core.auth import AuthService

class UserService:
    @staticmethod
    def create_user(db: Session, username: str, email: str, password: str) -> User:
        # 检查用户是否已存在
        if db.query(User).filter(
            (User.username == username) | (User.email == email)
        ).first():
            raise ValueError("User already exists")

        user = User(
            username=username,
            email=email,
            password_hash=AuthService.hash_password(password),
            timezone='Asia/Shanghai'  # 默认中国时区
        )
        db.add(user)
        db.commit()
        db.refresh(user)
        return user

    @staticmethod
    def authenticate(db: Session, username: str, password: str) -> Optional[User]:
        user = db.query(User).filter(
            (User.username == username) | (User.email == username)
        ).first()

        if user and AuthService.verify_password(password, user.password_hash):
            # 更新最后登录时间
            user.last_login_at = datetime.utcnow()
            db.commit()
            return user
        return None

    @staticmethod
    def get_user_documents(db: Session, user_id: str, folder_id: Optional[str] = None):
        query = db.query(Document).filter(Document.owner_id == user_id)

        if folder_id:
            query = query.filter(Document.folder_id == folder_id)

        return query.order_by(Document.updated_at.desc()).all()
```

### 3.2 多文档管理

#### 3.2.1 文档列表 API

```python
# backend/app/api/routes/documents.py
from fastapi import Depends, Query
from typing import Optional

@router.get("/my-documents", response_model=List[DocumentListResponse])
async def get_my_documents(
    folder_id: Optional[str] = None,
    search: Optional[str] = None,
    sort_by: str = Query(default="updated_at", pattern="^(title|created_at|updated_at)$"),
    order: str = Query(default="desc", pattern="^(asc|desc)$"),
    skip: int = Query(default=0, ge=0),
    limit: int = Query(default=20, le=100),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取当前用户的文档列表"""
    query = db.query(Document).filter(Document.owner_id == current_user.id)

    # 文件夹筛选
    if folder_id:
        query = query.filter(Document.folder_id == folder_id)

    # 搜索
    if search:
        query = query.filter(Document.title.contains(search))

    # 排序
    order_column = getattr(Document, sort_by)
    if order == "desc":
        query = query.order_by(order_column.desc())
    else:
        query = query.order_by(order_column.asc())

    # 分页
    total = query.count()
    documents = query.offset(skip).limit(limit).all()

    return {
        "items": documents,
        "total": total,
        "skip": skip,
        "limit": limit
    }

@router.get("/shared-with-me", response_model=List[DocumentListResponse])
async def get_shared_documents(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取分享给我的文档"""
    shared_docs = db.query(Document).join(DocumentPermission).filter(
        DocumentPermission.user_id == current_user.id
    ).all()

    return shared_docs

@router.get("/recent", response_model=List[DocumentListResponse])
async def get_recent_documents(
    limit: int = Query(default=10, le=50),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取最近访问的文档"""
    docs = db.query(Document).filter(
        Document.owner_id == current_user.id,
        Document.last_accessed_at.isnot(None)
    ).order_by(
        Document.last_accessed_at.desc()
    ).limit(limit).all()

    return docs
```

#### 3.2.2 文件夹管理

```python
# backend/app/api/routes/folders.py
@router.post("/folders", response_model=FolderResponse)
async def create_folder(
    data: FolderCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """创建文件夹"""
    folder = Folder(
        name=data.name,
        description=data.description,
        parent_id=data.parent_id,
        owner_id=current_user.id,
        color=data.color,
        icon=data.icon
    )
    db.add(folder)
    db.commit()
    db.refresh(folder)
    return folder

@router.get("/folders/tree", response_model=List[FolderTreeNode])
async def get_folder_tree(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取文件夹树形结构"""
    def build_tree(parent_id=None):
        folders = db.query(Folder).filter(
            Folder.owner_id == current_user.id,
            Folder.parent_id == parent_id
        ).all()

        tree = []
        for folder in folders:
            node = {
                "id": folder.id,
                "name": folder.name,
                "color": folder.color,
                "icon": folder.icon,
                "document_count": db.query(Document).filter(
                    Document.folder_id == folder.id
                ).count(),
                "children": build_tree(folder.id)
            }
            tree.append(node)

        return tree

    return build_tree()
```

### 3.3 权限管理

```python
# backend/app/services/permission_service.py
class PermissionService:
    @staticmethod
    def check_document_permission(
        db: Session,
        user_id: str,
        document_id: str,
        required_permission: str = "view"
    ) -> bool:
        document = db.query(Document).filter(Document.id == document_id).first()

        if not document:
            return False

        # 文档所有者拥有所有权限
        if document.owner_id == user_id:
            return True

        # 公开文档允许查看
        if document.is_public and required_permission == "view":
            return True

        # 检查权限表
        permission = db.query(DocumentPermission).filter(
            DocumentPermission.document_id == document_id,
            DocumentPermission.user_id == user_id
        ).first()

        if not permission:
            return False

        # 检查权限级别
        permission_levels = {"view": 1, "edit": 2, "admin": 3}
        return permission_levels[permission.permission] >= permission_levels[required_permission]

    @staticmethod
    def share_document(
        db: Session,
        document_id: str,
        user_id: str,
        shared_with_user_id: str,
        permission: str = "view"
    ):
        # 验证操作者权限
        if not PermissionService.check_document_permission(
            db, user_id, document_id, "admin"
        ):
            raise PermissionError("No permission to share this document")

        # 创建或更新权限
        doc_permission = db.query(DocumentPermission).filter(
            DocumentPermission.document_id == document_id,
            DocumentPermission.user_id == shared_with_user_id
        ).first()

        if doc_permission:
            doc_permission.permission = permission
            doc_permission.granted_by = user_id
            doc_permission.granted_at = datetime.utcnow()
        else:
            doc_permission = DocumentPermission(
                document_id=document_id,
                user_id=shared_with_user_id,
                permission=permission,
                granted_by=user_id
            )
            db.add(doc_permission)

        db.commit()
        return doc_permission
```

### 3.4 修复时区问题

```python
# backend/app/core/config.py
from zoneinfo import ZoneInfo

class Settings(BaseSettings):
    # ... 其他配置
    DEFAULT_TIMEZONE: str = "Asia/Shanghai"

    def get_local_time(self, utc_time: datetime) -> datetime:
        """将 UTC 时间转换为本地时间"""
        if utc_time.tzinfo is None:
            utc_time = utc_time.replace(tzinfo=ZoneInfo("UTC"))
        local_tz = ZoneInfo(self.DEFAULT_TIMEZONE)
        return utc_time.astimezone(local_tz)

# backend/app/schemas/document.py
from datetime import datetime
from zoneinfo import ZoneInfo

class VersionResponse(BaseModel):
    # ... 其他字段
    created_at: datetime

    class Config:
        json_encoders = {
            datetime: lambda v: v.astimezone(ZoneInfo("Asia/Shanghai")).isoformat()
        }

# 或者在 API 层面处理
@router.get("/documents/{id}")
async def get_document(id: str, db: Session = Depends(get_db)):
    document = DocumentService.get_document(db, id)

    # 转换时区
    if document:
        document.created_at = settings.get_local_time(document.created_at)
        document.updated_at = settings.get_local_time(document.updated_at)

    return document
```

---

## 四、前端实现方案

### 4.1 路由与权限

```typescript
// frontend/src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/login',
      name: 'Login',
      component: () => import('@/views/LoginView.vue'),
      meta: { requiresAuth: false }
    },
    {
      path: '/register',
      name: 'Register',
      component: () => import('@/views/RegisterView.vue'),
      meta: { requiresAuth: false }
    },
    {
      path: '/',
      name: 'Dashboard',
      component: () => import('@/views/DashboardView.vue'),
      meta: { requiresAuth: true },
      children: [
        {
          path: 'documents',
          name: 'DocumentList',
          component: () => import('@/views/DocumentListView.vue')
        },
        {
          path: 'documents/:id',
          name: 'DocumentEdit',
          component: () => import('@/views/DocumentView.vue')
        },
        {
          path: 'folders/:folderId?',
          name: 'FolderView',
          component: () => import('@/views/FolderView.vue')
        },
        {
          path: 'shared',
          name: 'SharedDocuments',
          component: () => import('@/views/SharedView.vue')
        },
        {
          path: 'recent',
          name: 'RecentDocuments',
          component: () => import('@/views/RecentView.vue')
        }
      ]
    }
  ]
})

// 路由守卫
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()

  // 检查是否需要认证
  if (to.meta.requiresAuth) {
    if (!authStore.isAuthenticated) {
      // 尝试从 localStorage 恢复会话
      await authStore.restoreSession()

      if (!authStore.isAuthenticated) {
        return next({ name: 'Login', query: { redirect: to.fullPath } })
      }
    }
  }

  next()
})

export default router
```

### 4.2 认证 Store

```typescript
// frontend/src/stores/auth.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { authApi } from '@/api/auth'
import type { User, LoginRequest, RegisterRequest } from '@/types'

export const useAuthStore = defineStore('auth', () => {
  const user = ref<User | null>(null)
  const token = ref<string | null>(null)
  const isLoading = ref(false)

  const isAuthenticated = computed(() => !!token.value)

  async function login(credentials: LoginRequest) {
    isLoading.value = true
    try {
      const response = await authApi.login(credentials)
      token.value = response.access_token
      user.value = response.user

      // 保存到 localStorage
      localStorage.setItem('token', response.access_token)
      localStorage.setItem('user', JSON.stringify(response.user))

      // 设置 axios 默认 header
      api.defaults.headers.common['Authorization'] = `Bearer ${response.access_token}`

      return response
    } finally {
      isLoading.value = false
    }
  }

  async function register(data: RegisterRequest) {
    isLoading.value = true
    try {
      const response = await authApi.register(data)
      // 注册成功后自动登录
      await login({ username: data.username, password: data.password })
      return response
    } finally {
      isLoading.value = false
    }
  }

  function logout() {
    user.value = null
    token.value = null
    localStorage.removeItem('token')
    localStorage.removeItem('user')
    delete api.defaults.headers.common['Authorization']

    // 跳转到登录页
    router.push('/login')
  }

  async function restoreSession() {
    const savedToken = localStorage.getItem('token')
    const savedUser = localStorage.getItem('user')

    if (savedToken && savedUser) {
      try {
        // 验证 token 是否有效
        const response = await authApi.verifyToken(savedToken)
        if (response.valid) {
          token.value = savedToken
          user.value = JSON.parse(savedUser)
          api.defaults.headers.common['Authorization'] = `Bearer ${savedToken}`
          return true
        }
      } catch {
        // Token 无效，清理本地存储
        logout()
      }
    }
    return false
  }

  return {
    user,
    token,
    isLoading,
    isAuthenticated,
    login,
    register,
    logout,
    restoreSession
  }
})
```

### 4.3 文档列表界面

```vue
<!-- frontend/src/views/DocumentListView.vue -->
<template>
  <div class="document-list">
    <!-- 顶部工具栏 -->
    <div class="toolbar">
      <div class="left-section">
        <button @click="createDocument" class="btn btn-primary">
          <Icon name="plus" /> 新建文档
        </button>

        <div class="view-toggle">
          <button
            :class="{ active: viewMode === 'grid' }"
            @click="viewMode = 'grid'"
          >
            <Icon name="grid" />
          </button>
          <button
            :class="{ active: viewMode === 'list' }"
            @click="viewMode = 'list'"
          >
            <Icon name="list" />
          </button>
        </div>
      </div>

      <div class="right-section">
        <!-- 搜索框 -->
        <div class="search-box">
          <Icon name="search" />
          <input
            v-model="searchQuery"
            @input="debouncedSearch"
            placeholder="搜索文档..."
          />
        </div>

        <!-- 排序选项 -->
        <select v-model="sortBy" @change="loadDocuments" class="sort-select">
          <option value="updated_at">最近修改</option>
          <option value="created_at">创建时间</option>
          <option value="title">标题</option>
        </select>
      </div>
    </div>

    <!-- 文件夹路径导航 -->
    <div class="breadcrumb" v-if="currentFolder">
      <a @click="navigateToFolder(null)">我的文档</a>
      <template v-for="folder in folderPath" :key="folder.id">
        <span class="separator">/</span>
        <a @click="navigateToFolder(folder.id)">{{ folder.name }}</a>
      </template>
    </div>

    <!-- 文档网格/列表 -->
    <div v-if="viewMode === 'grid'" class="document-grid">
      <div
        v-for="doc in documents"
        :key="doc.id"
        class="document-card"
        @click="openDocument(doc.id)"
      >
        <div class="card-header">
          <Icon :name="doc.icon || 'document'" />
          <div class="card-menu">
            <button @click.stop="showDocumentMenu(doc, $event)">
              <Icon name="more" />
            </button>
          </div>
        </div>

        <div class="card-body">
          <h3>{{ doc.title }}</h3>
          <p class="preview">{{ doc.preview }}</p>
        </div>

        <div class="card-footer">
          <span class="date">{{ formatDate(doc.updated_at) }}</span>
          <div class="stats">
            <span v-if="doc.is_shared">
              <Icon name="share" />
            </span>
            <span>{{ doc.version_count }} 版本</span>
          </div>
        </div>
      </div>
    </div>

    <div v-else class="document-table">
      <table>
        <thead>
          <tr>
            <th>标题</th>
            <th>文件夹</th>
            <th>最后修改</th>
            <th>版本数</th>
            <th>操作</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="doc in documents" :key="doc.id">
            <td>
              <a @click="openDocument(doc.id)">{{ doc.title }}</a>
            </td>
            <td>{{ doc.folder_name || '-' }}</td>
            <td>{{ formatDate(doc.updated_at) }}</td>
            <td>{{ doc.version_count }}</td>
            <td>
              <button @click="showDocumentMenu(doc, $event)">
                <Icon name="more" />
              </button>
            </td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- 分页 -->
    <div class="pagination" v-if="totalPages > 1">
      <button
        @click="currentPage--"
        :disabled="currentPage === 1"
      >
        上一页
      </button>
      <span>{{ currentPage }} / {{ totalPages }}</span>
      <button
        @click="currentPage++"
        :disabled="currentPage === totalPages"
      >
        下一页
      </button>
    </div>

    <!-- 右键菜单 -->
    <ContextMenu
      v-if="showMenu"
      :x="menuX"
      :y="menuY"
      @close="showMenu = false"
    >
      <div @click="renameDocument">重命名</div>
      <div @click="moveDocument">移动到...</div>
      <div @click="shareDocument">分享</div>
      <div @click="duplicateDocument">复制</div>
      <hr />
      <div @click="deleteDocument" class="danger">删除</div>
    </ContextMenu>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import { useRouter } from 'vue-router'
import { useDocumentStore } from '@/stores/document'
import { useAuthStore } from '@/stores/auth'
import { documentApi } from '@/api/client'
import { useDebounceFn } from '@vueuse/core'
import { formatDate } from '@/utils/date'

const router = useRouter()
const documentStore = useDocumentStore()
const authStore = useAuthStore()

const documents = ref([])
const viewMode = ref<'grid' | 'list'>('grid')
const searchQuery = ref('')
const sortBy = ref('updated_at')
const currentPage = ref(1)
const pageSize = 20
const totalCount = ref(0)
const currentFolder = ref(null)
const folderPath = ref([])

// 右键菜单
const showMenu = ref(false)
const menuX = ref(0)
const menuY = ref(0)
const selectedDocument = ref(null)

const totalPages = computed(() => Math.ceil(totalCount.value / pageSize))

const debouncedSearch = useDebounceFn(() => {
  currentPage.value = 1
  loadDocuments()
}, 300)

async function loadDocuments() {
  try {
    const response = await documentApi.getMyDocuments({
      folder_id: currentFolder.value?.id,
      search: searchQuery.value,
      sort_by: sortBy.value,
      order: 'desc',
      skip: (currentPage.value - 1) * pageSize,
      limit: pageSize
    })

    documents.value = response.items
    totalCount.value = response.total
  } catch (error) {
    console.error('Failed to load documents:', error)
  }
}

async function createDocument() {
  const doc = await documentApi.create({
    title: '未命名文档',
    folder_id: currentFolder.value?.id,
    initial_content: ''
  })

  router.push(`/documents/${doc.id}`)
}

function openDocument(id: string) {
  router.push(`/documents/${id}`)
}

function showDocumentMenu(doc, event: MouseEvent) {
  event.preventDefault()
  selectedDocument.value = doc
  menuX.value = event.clientX
  menuY.value = event.clientY
  showMenu.value = true
}

async function deleteDocument() {
  if (confirm(`确定删除 "${selectedDocument.value.title}" 吗？`)) {
    await documentApi.delete(selectedDocument.value.id)
    await loadDocuments()
  }
  showMenu.value = false
}

// 监听分页变化
watch(currentPage, loadDocuments)

onMounted(() => {
  loadDocuments()
})
</script>
```

---

## 五、MySQL 迁移指南

### 5.1 安装 MySQL 驱动

```bash
# 后端依赖
pip install pymysql
pip install mysqlclient  # 或者使用 PyMySQL

# 更新 requirements.txt
echo "pymysql==1.1.0" >> requirements.txt
```

### 5.2 修改数据库配置

```python
# backend/app/core/config.py
class Settings(BaseSettings):
    # MySQL 连接字符串
    DATABASE_URL: str = "mysql+pymysql://username:password@localhost:3306/textdiff?charset=utf8mb4"

    # 连接池配置
    DATABASE_POOL_SIZE: int = 10
    DATABASE_POOL_RECYCLE: int = 3600
    DATABASE_POOL_PRE_PING: bool = True

# backend/app/core/database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

engine = create_engine(
    settings.DATABASE_URL,
    pool_size=settings.DATABASE_POOL_SIZE,
    pool_recycle=settings.DATABASE_POOL_RECYCLE,
    pool_pre_ping=settings.DATABASE_POOL_PRE_PING,
    echo=settings.DEBUG  # 开发环境打印 SQL
)
```

### 5.3 数据迁移脚本

```python
# backend/migrations/sqlite_to_mysql.py
import sqlite3
import pymysql
from datetime import datetime

def migrate_data():
    # 连接 SQLite
    sqlite_conn = sqlite3.connect('textdiff.db')
    sqlite_cursor = sqlite_conn.cursor()

    # 连接 MySQL
    mysql_conn = pymysql.connect(
        host='localhost',
        user='username',
        password='password',
        database='textdiff',
        charset='utf8mb4'
    )
    mysql_cursor = mysql_conn.cursor()

    # 迁移文档表
    sqlite_cursor.execute("SELECT * FROM documents")
    documents = sqlite_cursor.fetchall()

    for doc in documents:
        mysql_cursor.execute("""
            INSERT INTO documents (id, title, created_at, updated_at, owner_id)
            VALUES (%s, %s, %s, %s, %s)
        """, (doc[0], doc[1], doc[2], doc[3], 'default_user_id'))

    # 迁移版本表
    sqlite_cursor.execute("SELECT * FROM versions")
    versions = sqlite_cursor.fetchall()

    for ver in versions:
        mysql_cursor.execute("""
            INSERT INTO versions (
                id, document_id, version_number, content,
                content_hash, created_at, author, save_type
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """, ver)

    mysql_conn.commit()

    print(f"迁移完成: {len(documents)} 个文档, {len(versions)} 个版本")

    sqlite_conn.close()
    mysql_conn.close()

if __name__ == "__main__":
    migrate_data()
```

---

## 六、部署方案

### 6.1 Docker 部署

```dockerfile
# backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    default-libmysqlclient-dev \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: root_password
      MYSQL_DATABASE: textdiff
      MYSQL_USER: textdiff_user
      MYSQL_PASSWORD: textdiff_password
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./backend/migrations/init.sql:/docker-entrypoint-initdb.d/init.sql
    command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci

  backend:
    build: ./backend
    environment:
      DATABASE_URL: mysql+pymysql://textdiff_user:textdiff_password@mysql:3306/textdiff?charset=utf8mb4
      SECRET_KEY: your-secret-key-here
      REDIS_URL: redis://redis:6379/0
    ports:
      - "8000:8000"
    depends_on:
      - mysql
      - redis
    volumes:
      - ./backend:/app

  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  mysql_data:
  redis_data:
```

### 6.2 Nginx 配置

```nginx
# nginx.conf
server {
    listen 80;
    server_name your-domain.com;

    # 前端静态文件
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
    }

    # API 代理
    location /api {
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # WebSocket 代理
    location /ws {
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # 开启 Gzip
    gzip on;
    gzip_vary on;
    gzip_min_length 10240;
    gzip_proxied expired no-cache no-store private auth;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml;
}
```

---

## 七、优化建议

### 7.1 性能优化

1. **数据库索引优化**
   - 为常用查询字段添加索引
   - 使用复合索引优化多条件查询
   - 定期分析慢查询日志

2. **缓存策略**
   - Redis 缓存热门文档
   - 缓存 diff 结果
   - 用户会话缓存

3. **前端优化**
   - 虚拟滚动处理大列表
   - 图片懒加载
   - 代码分割和懒加载

### 7.2 安全加固

1. **API 安全**
   - Rate limiting
   - SQL 注入防护
   - XSS 防护
   - CSRF 保护

2. **数据安全**
   - 敏感数据加密存储
   - HTTPS 强制
   - 定期备份

3. **审计日志**
   - 记录所有关键操作
   - 异常行为检测

### 7.3 功能增强

1. **协作功能**
   - 实时协同编辑
   - 评论和批注
   - 版本对比选择

2. **导出功能**
   - PDF 导出
   - Word 导出
   - Markdown 导出

3. **集成功能**
   - Git 集成
   - 第三方存储服务
   - Webhook 通知

---

## 八、开发计划

### Phase 1: 基础功能（2周）
- [x] 系统架构设计
- [x] MySQL 数据库搭建
- [x] 用户认证系统 (后端✅ 前端✅)
- [ ] 多文档管理基础功能
- [x] 时区问题修复

### Phase 2: 核心功能（2周）
- [ ] 文件夹管理
- [ ] 权限系统
- [ ] 文档分享功能
- [ ] 搜索功能
- [ ] 前端界面优化

### Phase 3: 高级功能（2周）
- [ ] 实时协作
- [ ] 审计日志
- [ ] 导出功能
- [ ] 性能优化
- [ ] 部署脚本

### Phase 4: 测试与部署（1周）
- [ ] 单元测试
- [ ] 集成测试
- [ ] 压力测试
- [ ] 生产环境部署
- [ ] 监控配置

---

## 九、详细实现步骤

### 9.1 Phase 1: 基础架构升级（第1周）

#### Step 1.1: MySQL 数据库迁移
**优先级: 🔴 必须**
**预计时间: 2天**

1. **安装和配置 MySQL**
   ```bash
   # macOS
   brew install mysql
   brew services start mysql

   # Ubuntu/Debian
   sudo apt update
   sudo apt install mysql-server
   sudo systemctl start mysql
   ```

2. **创建数据库和用户**
   ```sql
   -- 登录 MySQL
   mysql -u root -p

   -- 创建数据库
   CREATE DATABASE textdiff CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

   -- 创建用户
   CREATE USER 'textdiff_user'@'localhost' IDENTIFIED BY 'your_password';
   GRANT ALL PRIVILEGES ON textdiff.* TO 'textdiff_user'@'localhost';
   FLUSH PRIVILEGES;
   ```

3. **修改后端数据库配置**
   - 更新 `backend/requirements.txt` 添加 MySQL 驱动
   - 修改 `backend/app/core/config.py` 数据库连接字符串
   - 修改 `backend/app/core/database.py` 连接池配置

4. **执行数据库初始化脚本**
   - 创建 `backend/migrations/001_init_mysql.sql`
   - 运行所有建表语句
   - 创建索引和外键约束

#### Step 1.2: 修复时区问题
**优先级: 🔴 必须**
**预计时间: 0.5天**

1. **后端时区配置**
   - 在 `Settings` 类添加 `DEFAULT_TIMEZONE = "Asia/Shanghai"`
   - 创建时区转换工具函数 `convert_to_local_time()`
   - 修改所有 datetime 字段的序列化方法

2. **数据库时区设置**
   ```sql
   -- 设置 MySQL 时区
   SET GLOBAL time_zone = '+8:00';
   SET time_zone = '+8:00';
   ```

3. **前端时间显示**
   - 创建 `frontend/src/utils/date.ts` 时间格式化工具
   - 使用 `dayjs` 或 `date-fns` 处理时区
   - 统一所有时间显示格式

4. **测试验证**
   - 创建新版本，检查时间显示
   - 验证不同时区下的显示正确性

#### Step 1.3: 用户认证系统 - 后端
**优先级: 🔴 必须**
**预计时间: 2天**

1. **创建用户模型**
   ```python
   # backend/app/models/user.py
   - User 模型类
   - UserSession 模型类
   - 密码加密字段
   - 时间戳字段
   ```

2. **实现认证服务**
   ```python
   # backend/app/core/auth.py
   - hash_password() - 密码哈希
   - verify_password() - 密码验证
   - create_access_token() - 生成 JWT
   - decode_token() - 解析 JWT
   - get_current_user() - 依赖注入获取当前用户
   ```

3. **创建用户 API 端点**
   ```python
   # backend/app/api/routes/auth.py
   - POST /api/auth/register - 用户注册
   - POST /api/auth/login - 用户登录
   - POST /api/auth/logout - 用户登出
   - GET /api/auth/me - 获取当前用户信息
   - POST /api/auth/refresh - 刷新 token
   ```

4. **添加认证中间件**
   - 所有 API 端点添加认证检查
   - 排除公开端点（登录、注册）
   - 处理 token 过期和刷新

#### Step 1.4: 用户认证系统 - 前端
**优先级: 🔴 必须**
**预计时间: 1.5天**

1. **创建认证 Store**
   ```typescript
   // frontend/src/stores/auth.ts
   - user 状态管理
   - token 存储和管理
   - login() 方法
   - logout() 方法
   - register() 方法
   - refreshToken() 方法
   ```

2. **创建登录/注册页面**
   ```vue
   // frontend/src/views/LoginView.vue
   - 登录表单
   - 表单验证
   - 错误处理
   - 记住密码功能

   // frontend/src/views/RegisterView.vue
   - 注册表单
   - 密码强度检测
   - 邮箱验证
   - 用户协议
   ```

3. **配置路由守卫**
   ```typescript
   // frontend/src/router/index.ts
   - beforeEach 守卫检查认证
   - 重定向未认证用户到登录页
   - 保存原始访问路径
   - 处理 token 自动刷新
   ```

4. **更新 API 客户端**
   ```typescript
   // frontend/src/api/client.ts
   - 添加 Authorization header
   - 处理 401 错误自动刷新 token
   - 处理 token 过期重新登录
   ```

### 9.2 Phase 2: 多文档管理（第2-3周）

#### Step 2.1: 数据库模型扩展
**优先级: 🔴 必须**
**预计时间: 1天**

1. **文档所有权关联**
   - 给 documents 表添加 owner_id 字段
   - 创建用户-文档关联索引
   - 迁移现有数据到默认用户

2. **文件夹/分类系统**
   - 创建 folders 表
   - 支持嵌套文件夹（parent_id）
   - 文件夹权限继承

3. **文档元数据扩展**
   - 添加 last_accessed_at 字段
   - 添加 view_count 统计
   - 添加 is_public 标记
   - 添加文档标签系统

4. **数据迁移脚本**
   - 备份现有数据
   - 执行表结构变更
   - 更新现有记录

#### Step 2.2: 多文档 API 实现
**优先级: 🔴 必须**
**预计时间: 2天**

1. **文档列表 API**
   ```python
   # backend/app/api/routes/documents.py
   - GET /api/documents - 获取用户所有文档
   - GET /api/documents/folder/{folder_id} - 获取文件夹内文档
   - GET /api/documents/recent - 最近访问的文档
   - GET /api/documents/shared - 分享给我的文档
   - GET /api/documents/public - 公开文档
   ```

2. **文档搜索 API**
   ```python
   - GET /api/documents/search?q=keyword - 全文搜索
   - 支持标题、内容、标签搜索
   - 支持高级搜索条件（日期范围、作者等）
   - 搜索结果高亮
   ```

3. **文件夹管理 API**
   ```python
   # backend/app/api/routes/folders.py
   - POST /api/folders - 创建文件夹
   - PUT /api/folders/{id} - 更新文件夹
   - DELETE /api/folders/{id} - 删除文件夹
   - GET /api/folders/tree - 获取文件夹树
   - POST /api/folders/{id}/move - 移动文档到文件夹
   ```

4. **批量操作 API**
   ```python
   - POST /api/documents/batch/delete - 批量删除
   - POST /api/documents/batch/move - 批量移动
   - POST /api/documents/batch/export - 批量导出
   ```

#### Step 2.3: 前端文档管理界面
**优先级: 🔴 必须**
**预计时间: 3天**

1. **文档列表页面**
   ```vue
   // frontend/src/views/DocumentListView.vue
   - 网格视图和列表视图切换
   - 文档卡片组件
   - 排序选项（名称、日期、大小）
   - 分页组件
   - 文档预览
   ```

2. **侧边栏文件夹树**
   ```vue
   // frontend/src/components/FolderTree.vue
   - 递归树形组件
   - 拖拽移动文档
   - 右键菜单
   - 文件夹展开/折叠状态记忆
   ```

3. **搜索功能**
   ```vue
   // frontend/src/components/SearchBar.vue
   - 实时搜索建议
   - 搜索历史
   - 高级搜索面板
   - 搜索结果展示
   ```

4. **文档操作菜单**
   ```vue
   // frontend/src/components/DocumentActions.vue
   - 新建文档
   - 导入文档
   - 批量选择
   - 批量操作工具栏
   ```

#### Step 2.4: 文档管理 Store
**优先级: 🔴 必须**
**预计时间: 1天**

1. **创建文档列表 Store**
   ```typescript
   // frontend/src/stores/documentList.ts
   - documents 数组状态
   - folders 树形结构
   - 当前文件夹
   - 搜索条件
   - 排序方式
   ```

2. **实现 Store Actions**
   - loadDocuments() - 加载文档列表
   - createDocument() - 创建新文档
   - deleteDocument() - 删除文档
   - moveDocument() - 移动文档
   - searchDocuments() - 搜索文档

3. **缓存优化**
   - 文档列表缓存
   - 搜索结果缓存
   - 乐观更新

4. **状态同步**
   - 多标签页同步
   - WebSocket 实时更新

### 9.3 Phase 3: 权限与协作（第4周）

#### Step 3.1: 权限系统设计
**优先级: 🟡 重要**
**预计时间: 1天**

1. **权限级别定义**
   - owner - 所有者，所有权限
   - admin - 管理员，可以分享和删除
   - editor - 编辑者，可以修改内容
   - viewer - 查看者，只读权限

2. **权限检查中间件**
   ```python
   # backend/app/middleware/permission.py
   - check_document_permission() - 检查文档权限
   - require_permission() - 装饰器
   - 权限继承规则
   ```

3. **权限缓存**
   - Redis 缓存用户权限
   - 权限变更时清除缓存
   - 定期刷新策略

4. **审计日志**
   - 记录所有权限变更
   - 记录访问日志
   - 异常操作告警

#### Step 3.2: 文档分享功能
**优先级: 🟡 重要**
**预计时间: 2天**

1. **分享 API 实现**
   ```python
   # backend/app/api/routes/sharing.py
   - POST /api/documents/{id}/share - 创建分享
   - GET /api/shares/{code} - 通过分享码访问
   - PUT /api/shares/{id} - 更新分享设置
   - DELETE /api/shares/{id} - 取消分享
   ```

2. **分享链接生成**
   - 生成唯一分享码
   - 支持密码保护
   - 支持过期时间
   - 支持访问次数限制

3. **权限管理界面**
   ```vue
   // frontend/src/components/ShareDialog.vue
   - 分享对话框
   - 权限级别选择
   - 用户搜索和添加
   - 分享链接生成和复制
   ```

4. **协作者列表**
   ```vue
   // frontend/src/components/CollaboratorList.vue
   - 显示所有协作者
   - 修改权限级别
   - 移除协作者
   - 在线状态显示
   ```

#### Step 3.3: 实时协作增强
**优先级: 🟡 重要**
**预计时间: 2天**

1. **WebSocket 消息扩展**
   ```python
   # backend/app/services/websocket_manager.py
   - 用户加入/离开房间
   - 光标位置同步
   - 选区同步
   - 编辑锁定机制
   ```

2. **冲突解决机制**
   - 操作转换（OT）算法
   - 版本向量时钟
   - 自动合并策略
   - 冲突提示

3. **协作状态显示**
   ```vue
   // frontend/src/components/CollaborationStatus.vue
   - 在线用户列表
   - 用户光标显示
   - 用户选区高亮
   - 编辑状态指示器
   ```

4. **协作通知**
   - 新协作者加入通知
   - 文档被修改通知
   - 权限变更通知

### 9.4 Phase 4: 搜索与优化（第5周）

#### Step 4.1: 全文搜索实现
**优先级: 🟡 重要**
**预计时间: 2天**

1. **MySQL 全文索引**
   ```sql
   -- 创建全文索引
   ALTER TABLE documents ADD FULLTEXT(title);
   ALTER TABLE versions ADD FULLTEXT(content);

   -- 中文分词支持
   SET GLOBAL innodb_ft_min_token_size = 2;
   ```

2. **搜索服务实现**
   ```python
   # backend/app/services/search_service.py
   - search_documents() - 文档搜索
   - search_in_versions() - 版本内容搜索
   - build_search_query() - 构建搜索查询
   - highlight_results() - 高亮搜索结果
   ```

3. **高级搜索功能**
   - 支持布尔运算符（AND、OR、NOT）
   - 支持通配符搜索
   - 支持正则表达式
   - 支持范围搜索（日期、大小）

4. **搜索优化**
   - 搜索结果缓存
   - 搜索建议预加载
   - 异步索引更新
   - 搜索性能监控

#### Step 4.2: 性能优化
**优先级: 🟢 可选**
**预计时间: 2天**

1. **数据库优化**
   - 添加必要的索引
   - 优化查询语句
   - 配置连接池
   - 开启查询缓存

2. **缓存策略**
   ```python
   # backend/app/core/cache.py
   - Redis 缓存配置
   - 文档内容缓存
   - diff 结果缓存
   - 用户会话缓存
   ```

3. **前端优化**
   - 虚拟滚动实现
   - 图片懒加载
   - 路由懒加载
   - 资源预加载

4. **API 优化**
   - 响应压缩
   - 分页优化
   - 并发控制
   - Rate limiting

#### Step 4.3: 导出功能
**优先级: 🟢 可选**
**预计时间: 1天**

1. **导出 API**
   ```python
   # backend/app/api/routes/export.py
   - GET /api/documents/{id}/export/pdf - 导出 PDF
   - GET /api/documents/{id}/export/word - 导出 Word
   - GET /api/documents/{id}/export/markdown - 导出 Markdown
   - GET /api/documents/{id}/export/html - 导出 HTML
   ```

2. **批量导出**
   - 支持多文档打包
   - ZIP 压缩下载
   - 保留文件夹结构
   - 包含版本历史

3. **导出模板**
   - 自定义页眉页脚
   - 自定义样式
   - 水印支持
   - 目录生成

### 9.5 Phase 5: 测试与部署（第6周）

#### Step 5.1: 单元测试
**优先级: 🔴 必须**
**预计时间: 2天**

1. **后端测试**
   ```python
   # backend/tests/
   - 用户认证测试
   - 文档 CRUD 测试
   - 权限系统测试
   - diff 算法测试
   ```

2. **前端测试**
   ```typescript
   // frontend/tests/
   - 组件单元测试
   - Store 测试
   - 路由测试
   - API 调用测试
   ```

3. **集成测试**
   - API 端到端测试
   - 用户流程测试
   - 性能测试
   - 安全测试

#### Step 5.2: 部署准备
**优先级: 🔴 必须**
**预计时间: 2天**

1. **Docker 容器化**
   - 编写 Dockerfile
   - 配置 docker-compose
   - 环境变量配置
   - 健康检查配置

2. **CI/CD 配置**
   - GitHub Actions 配置
   - 自动化测试
   - 自动化构建
   - 自动化部署

3. **监控配置**
   - 日志收集
   - 性能监控
   - 错误追踪
   - 告警配置

4. **备份策略**
   - 数据库定期备份
   - 增量备份
   - 异地备份
   - 恢复测试

## 十、开发进度甘特图

```
Week 1: 基础架构
├─ Day 1-2: MySQL 迁移 ████████
├─ Day 2.5: 时区修复 ██
├─ Day 3-4: 用户认证后端 ████████
└─ Day 4.5-5: 用户认证前端 ██████

Week 2-3: 多文档管理
├─ Day 1: 数据库模型 ████
├─ Day 2-3: 多文档 API ████████
├─ Day 4-6: 前端界面 ████████████
└─ Day 7: Store 实现 ████

Week 4: 权限与协作
├─ Day 1: 权限系统 ████
├─ Day 2-3: 分享功能 ████████
└─ Day 4-5: 实时协作 ████████

Week 5: 搜索与优化
├─ Day 1-2: 全文搜索 ████████
├─ Day 3-4: 性能优化 ████████
└─ Day 5: 导出功能 ████

Week 6: 测试与部署
├─ Day 1-2: 测试编写 ████████
├─ Day 3-4: 部署准备 ████████
└─ Day 5: 上线发布 ████
```

## 十一、风险评估与应对

### 11.1 技术风险

| 风险项 | 可能性 | 影响 | 应对策略 |
|-------|--------|------|---------|
| MySQL 迁移数据丢失 | 低 | 高 | 完整备份，分步迁移，回滚方案 |
| 认证系统安全漏洞 | 中 | 高 | 使用成熟框架，安全审计，渗透测试 |
| 实时协作冲突 | 高 | 中 | OT 算法，版本锁，冲突提示 |
| 性能瓶颈 | 中 | 中 | 缓存策略，数据库优化，CDN |
| 第三方依赖问题 | 低 | 低 | 版本锁定，替代方案 |

### 11.2 进度风险

| 风险项 | 应对策略 |
|-------|---------|
| 需求变更 | 敏捷开发，快速迭代 |
| 技术难点 | 预研关键技术，准备备选方案 |
| 人员不足 | 优先级排序，分阶段交付 |
| 测试时间不足 | 自动化测试，持续集成 |

## 十二、验收标准

### 12.1 功能验收

- [ ] 用户可以注册、登录、登出
- [ ] 用户可以创建、编辑、删除自己的文档
- [ ] 用户可以查看文档版本历史
- [ ] 用户可以对比不同版本差异
- [ ] 用户可以组织文档到文件夹
- [ ] 用户可以搜索文档
- [ ] 用户可以分享文档给其他用户
- [ ] 时间显示正确（无 8 小时偏差）
- [ ] 支持多人同时在线编辑

### 12.2 性能验收

- [ ] 页面加载时间 < 2秒
- [ ] API 响应时间 < 500ms
- [ ] 支持 1000+ 文档列表展示
- [ ] 支持 10MB 文档内容
- [ ] 支持 100+ 并发用户

### 12.3 安全验收

- [ ] 密码加密存储
- [ ] JWT Token 认证
- [ ] SQL 注入防护
- [ ] XSS 防护
- [ ] CSRF 防护
- [ ] 权限控制正常

## 十三、总结

本升级方案将 TextDiff 从单用户单文档系统升级为：
- **多用户多文档管理平台**
- **完整的权限和协作系统**
- **生产级 MySQL 数据库**
- **修复时区和其他已知问题**

核心改进：
1. 用户认证与授权
2. 多文档组织管理
3. MySQL 数据库支持
4. 时区问题修复
5. 协作与分享功能

预计开发周期：7周
预计工作量：2-3人团队

后续可扩展方向：
- 企业版多租户
- AI 辅助写作
- 版本控制集成
- 更多文件格式支持
---

## 十四、开发进度日志

### 2025-10-21

#### ✅ 已完成

**1. MySQL 数据库搭建 (Step 1.1)**
- 创建 `.env.mysql` 配置文件
- 创建 `001_init_mysql.sql` 初始化脚本(13张表)
- 创建 `00_admin_setup.sql` 管理员设置脚本
- 创建 `init_database.py` 和 `verify_database.py` 工具脚本
- 数据库已成功创建,包含以下表:
  - users (用户表)
  - user_sessions (用户会话表)
  - folders (文件夹表)
  - documents (文档表)
  - versions (版本表)
  - version_tags (版本标签表)
  - document_permissions (文档权限表)
  - document_shares (文档分享表)
  - user_favorites (用户收藏表)
  - audit_logs (审计日志表)
- 创建默认管理员账号: admin/admin123

**2. 时区问题修复 (Step 1.2)**

后端修改:
- 更新 `backend/app/core/config.py`
  - 添加 `DEFAULT_TIMEZONE = "Asia/Shanghai"`
  - 添加 `get_local_time()` 和 `get_utc_time()` 方法
- 更新 `backend/app/core/database.py`
  - 配置 MySQL 连接池
- 创建 `backend/app/utils/timezone.py`
  - 时区转换工具函数
- 更新 `backend/app/schemas/document.py`
  - 添加 `@field_serializer` 装饰器自动转换时区

前端修改:
- 创建 `frontend/src/utils/date.ts`
  - `formatDate()` - 格式化日期
  - `formatRelativeTime()` - 相对时间
  - `formatFriendly()` - 友好显示
  - `parseDate()` - 解析日期
  - `isToday()`, `isYesterday()` - 日期判断

**3. 用户认证系统 - 后端 (Step 1.3 - ✅ 已完成)**

数据模型:
- 创建 `backend/app/models/user.py`
  - User 模型类
  - UserSession 模型类
  - Folder 模型类

核心服务:
- 创建 `backend/app/core/auth.py` - JWT认证服务
  - `AuthService` 类:密码哈希、Token生成/解析
  - 依赖注入:获取当前用户、活跃用户、超级用户
  - 支持访问令牌(24小时)和刷新令牌(7天)

数据模型:
- 创建 `backend/app/schemas/user.py` - 用户数据模型
  - `UserCreate`, `UserLogin`, `UserUpdate`, `UserPasswordUpdate`
  - `UserResponse`, `TokenResponse`, `UserStats`
  - 所有datetime字段自动转换时区

业务逻辑:
- 创建 `backend/app/services/user_service.py` - 用户服务
  - 用户CRUD操作
  - 认证和会话管理
  - 用户统计信息

API路由:
- 创建 `backend/app/api/routes/auth.py` - 11个认证端点
  - POST `/api/auth/register` - 注册
  - POST `/api/auth/login` - 登录
  - POST `/api/auth/logout` - 登出
  - POST `/api/auth/refresh` - 刷新Token
  - GET/PUT `/api/auth/me` - 当前用户信息
  - POST `/api/auth/me/password` - 修改密码
  - GET `/api/auth/me/stats` - 用户统计
  - GET/DELETE `/api/auth/users/*` - 管理员接口

主程序:
- 更新 `backend/app/main.py` - 注册auth路由

依赖包:
- 更新 `backend/requirements.txt` 和 `.env`
  - pymysql==1.1.2, cryptography==46.0.3
  - python-jose==3.5.0, passlib==1.7.4, bcrypt==5.0.0
  - email-validator==2.3.0

测试结果:
- ✅ 所有模块导入成功
- ✅ 11个认证端点全部注册
- ✅ FastAPI应用初始化正常

**4. 用户认证系统 - 前端 (Step 1.4 - ✅ 已完成)**

认证Store:
- 创建 `frontend/src/stores/auth.ts` - Pinia认证状态管理
  - 用户状态、Token管理
  - register(), login(), logout() 方法
  - restoreSession() - 自动恢复登录会话
  - refreshAccessToken() - 自动刷新Token
  - updateProfile(), updatePassword() - 用户管理

API客户端:
- 更新 `frontend/src/api/client.ts`
  - 请求拦截器:自动添加Authorization header
  - 响应拦截器:401自动刷新Token重试
  - Token过期自动跳转登录页

页面组件:
- 创建 `frontend/src/views/LoginView.vue` - 登录页面
  - 用户名/邮箱登录
  - 记住我选项
  - 错误提示
  - 美观的渐变UI设计

- 创建 `frontend/src/views/RegisterView.vue` - 注册页面
  - 用户名、邮箱、密码注册
  - 密码强度指示器
  - 密码确认验证
  - 表单实时验证

路由配置:
- 更新 `frontend/src/router/index.ts`
  - 添加/login和/register路由
  - beforeEach路由守卫:自动检查认证状态
  - 未登录用户重定向到登录页
  - 已登录用户访问登录页重定向到首页
  - 保存并恢复原始访问路径

测试功能:
- ✅ 用户注册流程
- ✅ 用户登录流程
- ✅ Token自动刷新
- ✅ 会话自动恢复
- ✅ 路由权限控制

#### ⏳ 待开始

**多文档管理基础功能**
- 文档列表API
- 文件夹管理
- 文档搜索

#### 📝 技术要点

1. **数据库连接**: PyMySQL驱动, 连接池配置, utf8mb4字符集
2. **时区处理**: UTC存储, Asia/Shanghai显示, Pydantic自动转换
3. **密码安全**: bcrypt算法, passlib库
4. **JWT Token**: python-jose库, 24小时过期

#### 🐛 已修复问题

1. SQL语法错误: MySQL CREATE DATABASE不支持COMMENT - 已移除
2. 数据库未选择: 添加 USE textdiff;
3. 权限不足: 管理员授权

#### 📊 数据库状态

- 服务器: 23.19.231.78:3306
- 数据库: textdiff (utf8mb4_unicode_ci)
- 时区: +8:00
- 表数量: 13
- 索引和外键: 已配置

#### 🔜 下一步计划

1. 完成用户认证后端实现
2. 测试用户注册和登录功能
3. 实现前端认证界面
4. 集成测试整个认证流程

**5. 多文档管理系统 - 后端 (进行中)**

数据模型更新:
- 更新 `backend/app/models/document.py`
  - Document添加owner_id和folder_id字段
  - Document添加owner和folder关系
  - Version添加author_id字段
  - Version添加author_user关系

业务逻辑更新:
- 更新 `backend/app/services/version_service.py`
  - create_document()添加owner_id参数
  - create_version()添加author_id参数
  - 新增get_user_documents()方法-获取用户文档列表
  - 支持按文件夹筛选

API更新:
- 更新 `backend/app/api/routes/documents.py`
  - 所有端点添加用户认证(get_current_active_user)
  - create_document()自动设置owner_id
  - get_documents()改为获取当前用户文档
  - 所有文档操作添加权限检查(owner验证)
  - create_version()添加author_id支持
  - 支持folder_id参数筛选

权限控制:
- ✅ 用户只能访问自己的文档
- ✅ 用户只能修改/删除自己的文档
- ✅ 版本自动关联作者ID
- ✅ 403 Forbidden错误处理

**6. 多文档管理系统 - 前端 (✅ 已完成)**

页面组件:
- 创建 `frontend/src/views/DocumentListView.vue` - 文档列表页面
  - 网格布局展示文档卡片
  - 文档标题、版本号、更新时间显示
  - 搜索框实时搜索(300ms防抖)
  - 排序选项:最近更新/创建时间/标题
  - 创建新文档按钮
  - 右键菜单:重命名/删除
  - 分页控制
  - 空状态提示
  - 加载状态spinner

导航组件:
- 创建 `frontend/src/components/Navbar.vue` - 导航栏组件
  - 品牌Logo和标题
  - 导航链接(我的文档)
  - 用户信息显示(头像、用户名)
  - 用户下拉菜单:
    - 个人资料
    - 设置
    - 退出登录
  - 响应式设计
  - 美观的渐变UI设计

应用集成:
- 更新 `frontend/src/App.vue`
  - 集成Navbar组件
  - 根据路由显示/隐藏导航栏
  - 在登录/注册页不显示导航栏
  - 统一的应用布局结构

路由更新:
- 更新 `frontend/src/router/index.ts`
  - 首页路由指向DocumentListView
  - 添加/documents路由
  - 保留/document/:id详情页路由
  - 所有路由都需要认证

功能测试:
- ✅ 文档列表加载显示
- ✅ 创建新文档
- ✅ 文档重命名
- ✅ 文档删除
- ✅ 搜索文档
- ✅ 排序切换
- ✅ 分页功能
- ✅ 导航栏显示
- ✅ 用户菜单交互

